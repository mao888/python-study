"""
Python中的变量不是在哪个位置都可以访问的，具体的访问权限取决于定义变量的位置。变量所处的有效范围称为变量的作用域。
根据变量作用域的不同，可以将变量分为两类：全局变量和局部变量。
全局变量是指在函数之外定义的变量，一般没有缩进，在程序执行的全过程有效。
局部变量是指在函数内部定义的变量，仅在函数内部有效，一旦退出函数，变量就不再有效。
想要在函数中使用全局变量，一般会使用global声明。
下面通过几个案例的运行结果来理解全局变量和局部变量的使用，代码如下：
"""
n = 1
def fun(a, b):
    n = a * b  #此处n是与全局变量同名的局部变量
    return a + b
s=fun(10, 12)
print(s, n) #输出22 1

"""
从运行结果中可以看出，尽管调用了函数，但变量n的值并未发生改变。
原因是：虽然在主程序中声明了全局变量n，但是在函数中并没有使用global关键字声明，
而函数fun（）有自己的内存空间，它会将n=a∗b理解为生成一个局部变量n，并将两个参数之积赋给它。
所以在函数中出现的变量n其实是一个局部变量，与全局变量n是两个完全不同的独立变量，代码如下：
"""
n = 1
def fun(a, b):
    global n
    n = a * b
    return a + b
s=fun(10, 12)
print(s, n) #输出22 120

"""
从运行结果可以发现，变量n的值经过函数调用后发生了变化。
这是由于在函数体中使用global关键字声明的变量n是全局变量，变量n在主程序和函数体中使用的是同一个内存空间。故而在调用函数时会改变内存空间中的值，代码如下：
"""
ls = []  # 创建一个全局列表变量
def fun(a, b):
    ls.append(a * b)  # 此处ls是全局变量
    return a + b
s = fun(10, 12)
print(s, ls)    #输出22 [120]
"""
从这个运行结果可以发现出现了神奇的事件，没有使用global声明的列表变量ls，它的值在函数调用后居然发生了改变。
原因是列表是组合数据类型，会对多个数据进行操作，它的使用有创建和引用的区别。
当列表被方括号（[ ]）赋值时，列表就会被真实地创建，否则就是对之前创建出来的列表进行引用，而普通的数据类型变量的赋值却没有创建和引用的区分。
在函数体中，虽然没有使用global声明的列表变量ls，但是出现ls.append（a∗b）语句时，仅仅是对列表ls进行引用。
而函数体中没有创建过这个名称的列表，fun（）函数就会进一步寻找全局内存空间，当在全局内存空间找到变量ls后，则会自动关联全局ls列表，并对其内容进行修改。
简而言之，对于列表类型，函数可以直接使用全局列表，而不需要采用global进行声明，代码如下：
"""
ls = []  # 创建一个全局列表变量
def fun(a, b):
    ls = []  # 此处ls是局部变量
    ls.append(a * b)
    return a + b
s = fun(10, 12)
print(s, ls)    #输出22 []
"""
由于在函数体中创建了一个局部变量ls，虽然名称与全局变量相同，但是出现了方括号（[ ]）赋值，列表就会在真实的fun（）函数的内存空间中创建，
语句ls.append（a∗b）所修改的就是fun（）函数内存空间的ls变量值，而不是全局变量ls的值。故全局变量ls的值仍然是空的。
由此，可以总结一下Python函数对变量的作用要遵守的原则：
（1）简单数据类型变量无论是否与全局变量重名，仅在函数内部创建和使用。函数退出后，变量就会被释放，而同名的全局变量不受函数调用影响。
（2）简单数据类型变量在使用global保留字声明后，作为全局变量使用，函数退出后，该变量仍被保留，且数值被函数改变。
（3）对于组合数据类型的全局变量，如果在函数内部没有被真实地创建同名变量，则函数内部可以直接使用并修改全局变量的值。
（4）如果函数内部真实地创建了组合数据类型变量，无论是否与全局变量同名，函数仅对内部的局部变量进行操作，函数退出后局部变量被释放，而全局变量的值不受函数影响。
"""